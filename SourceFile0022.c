#pragma config(Sensor, S1,     eyes,           sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     redButton,      sensorNone)
#pragma config(Motor,  motorB,          motorEyes,     tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorRight,    tmotorEV3_Medium, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motorA,          motorLeft,     tmotorEV3_Medium, PIDControl, reversed, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// min, max et modulo(negatifs?) ?
// movement ligne 226 (operateur |=)
// fabs = valeur absolue


/*
task avoidObstaclesPerso()
{
	int i = 1;
	float target = -45;
	int robotSpeed = 40;
	int eyesSpeed = 60;


	while(true){
		setMotorSpeed(motorLeft, robotSpeed);
		setMotorSpeed(motorRight, robotSpeed);

		while(getIRDistance(eyes) > 50) {

			setMotorTarget(motorEyes, target, eyesSpeed);

			//Holds program flow until the motor on port A comes to a complete stop.
			waitUntilMotorStop(motorEyes);

			target += 10*i;
			if (abs(target) >= 45)
				i *= -1;

		}

		setMotorSpeed(motorRight, 0);
		setMotorSpeed(motorLeft, 0);


		while (getIRDistance(eyes)<60) {

		}

	}
}
*/

#include "config.c"
#include "position.c"
#include "movement.c"
#include "sonar.c"

task main(){

	initConfig(AVERELL);
  initPosition(true);
  moveTo_forward(50,0);

	/*while(true)
	{
		int robotSpeed = 40;
		setMotorSpeed(motorLeft, robotSpeed);
		setMotorSpeed(motorRight, robotSpeed);
		while (getUSDistance(eyes)>50)
			{
			wait1Msec(10);
			}
		setMotorSpeed(motorLeft, 0);
		setMotorSpeed(motorRight, 0);
	}*/
	while (getMovementState() != NOMVT) {wait1Msec(20);}
	stopAllTasks();


}
